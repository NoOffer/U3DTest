#pragma kernel CSMain

RWStructuredBuffer<float3> Points;
int numPerSide;
RWTexture3D<float4> Result;

static const int3 offsets[] =
{
    // centre
    int3(0, 0, 0),
    // front face
    int3(0, 0, 1),
    int3(-1, 1, 1),
    int3(-1, 0, 1),
    int3(-1, -1, 1),
    int3(0, 1, 1),
    int3(0, -1, 1),
    int3(1, 1, 1),
    int3(1, 0, 1),
    int3(1, -1, 1),
    // back face
    int3(0, 0, -1),
    int3(-1, 1, -1),
    int3(-1, 0, -1),
    int3(-1, -1, -1),
    int3(0, 1, -1),
    int3(0, -1, -1),
    int3(1, 1, -1),
    int3(1, 0, -1),
    int3(1, -1, -1),
    // ring around center
    int3(-1, 1, 0),
    int3(-1, 0, 0),
    int3(-1, -1, 0),
    int3(0, 1, 0),
    int3(0, -1, 0),
    int3(1, 1, 0),
    int3(1, 0, 0),
    int3(1, -1, 0)
};

[numthreads(10, 10, 10)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float w, h, d;
    Result.GetDimensions(w, h, d);
    float3 pointPos = id / float3(w, h, d) * numPerSide;
    
    float minDist = 2;
    for (int i = 0; i < 27; i++)
    {
        float3 surroundCellPos = floor(pointPos) - offsets[i];
        surroundCellPos = float3(surroundCellPos.x % numPerSide, surroundCellPos.y % numPerSide, surroundCellPos.z % numPerSide);
        float surroundCellIdx = surroundCellPos.x + numPerSide * (surroundCellPos.y + numPerSide * surroundCellPos.z);
        minDist = min(minDist, length(pointPos - (surroundCellPos + Points[surroundCellIdx])));
    }
    minDist /= sqrt(2.5);

    Result[id] = float4(minDist, minDist, minDist, 1);
    //Result[id] = float4(id, 1);

}
